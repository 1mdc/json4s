{"google":"","name":"Json4s","body":"# JSON4S [![Build Status](https://jenkins.backchat.io/job/json4s/badge/icon)](https://jenkins.backchat.io/job/json4s/)\r\n\r\nAt this moment there are at least 6 json libraries for scala, not counting the java json libraries.\r\nAll these libraries have a very similar AST. This project aims to provide a single AST to be used by other scala\r\njson libraries.\r\n\r\nAt this moment the approach taken to working with the AST has been taken from lift-json and the native package\r\nis in fact lift-json but outside of the lift project.\r\n\r\n## Lift JSON\r\n\r\nThis project also attempts to set lift-json free from the release schedule imposed by the lift framework.\r\nThe Lift framework carries many dependencies and as such it's typically a blocker for many other scala projects when\r\na new version of scala is released.\r\n\r\nSo the native package in this library is in fact verbatim lift-json in a different package name, this means that\r\nyour import statements will change if you use this library.\r\n\r\n```scala\r\nimport org.json4s._\r\nimport org.json4s.native.JsonMethods._\r\n```\r\n\r\nAfter that everything works exactly the same as it would with lift-json\r\n\r\n## Jackson\r\n\r\nIn addition to the native parser there is also an implementation that uses jackson for parsing to the AST.\r\nThe jackson module includes most of the jackson-module-scala functionality and the ability to use it with the\r\nlift-json AST.\r\n\r\nTo use jackson instead of the native parser:\r\n\r\n```scala\r\nimport org.json4s._\r\nimport org.json4s.jackson.JsonMethods._\r\n```\r\n\r\n\r\n\r\n## Guide\r\n\r\nParsing and formatting utilities for JSON.\r\n\r\nA central concept in lift-json library is Json AST which models the structure of\r\na JSON document as a syntax tree.\r\n\r\n```scala\r\nsealed abstract class JValue\r\ncase object JNothing extends JValue // 'zero' for JValue\r\ncase object JNull extends JValue\r\ncase class JString(s: String) extends JValue\r\ncase class JDouble(num: Double) extends JValue\r\ncase class JDecimal(num: BigDecimal) extends JValue\r\ncase class JInt(num: BigInt) extends JValue\r\ncase class JBool(value: Boolean) extends JValue\r\ncase class JObject(obj: List[JField]) extends JValue\r\ncase class JArray(arr: List[JValue]) extends JValue\r\n\r\ntype JField = (String, JValue)\r\n```\r\n\r\nAll features are implemented in terms of above AST. Functions are used to transform\r\nthe AST itself, or to transform the AST between different formats. Common transformations\r\nare summarized in a following picture.\r\n\r\n![Json AST](https://raw.github.com/json4s/json4s/master/core/json.png)\r\n\r\nSummary of the features:\r\n\r\n* Fast JSON parser\r\n* LINQ style queries\r\n* Case classes can be used to extract values from parsed JSON\r\n* Diff & merge\r\n* DSL to produce valid JSON\r\n* XPath like expressions and HOFs to manipulate JSON\r\n* Pretty and compact printing\r\n* XML conversions\r\n* Serialization\r\n* Low level pull parser API\r\n\r\nInstallation\r\n============\r\n\r\nYou can add the json4s as a dependency in following ways.\r\nNote, replace XXX with correct Json4s version.\r\n\r\n### SBT users\r\n\r\nFor the native support add the following dependency to your project description:\r\n\r\n    val json4sNative = \"org.json4s\" %% \"json4s-native\" % \"3.1.0\"\r\n\r\nFor the Jackson support add the following dependency to your project description:\r\n\r\n    val json4sJackson = \"org.json4s\" %% \"json4s-jackson\" % \"3.1.0\"\r\n\r\n### Maven users\r\n\r\nFor the native support add the following dependency to your pom:\r\n\r\n    <dependency>\r\n      <groupId>org.json4s</groupId>\r\n      <artifactId>json4s-native_${scala.version}</artifactId>\r\n      <version>3.1.0</version>\r\n    </dependency>\r\n\r\nFor the jackson support add the following dependency to your pom:\r\n\r\n    <dependency>\r\n      <groupId>org.json4s</groupId>\r\n      <artifactId>json4s-jackson_${scala.version}</artifactId>\r\n      <version>3.1.0</version>\r\n    </dependency>\r\n\r\n### Others\r\n\r\nDownload following jars:\r\n\r\n* http://repo1.maven.org/maven2/org/json4s/3.1.0/json4s-core_2.9.2-3.1.0.jar\r\n* http://repo1.maven.org/maven2/org/json4s/3.1.0/json4s-native_2.9.2-3.1.0.jar\r\n* http://mirrors.ibiblio.org/pub/mirrors/maven2/com/thoughtworks/paranamer/paranamer/2.5.1/paranamer-2.5.1.jar\r\n* scalap (Only for Scala-2.9 compatible versions)\r\n\r\nExtras\r\n------\r\n\r\n* [ext](https://github.com/json4s/json4s/tree/master/ext)\r\n\r\nSupport for Enum, Joda-Time, ...\r\n\r\n* [scalaz](https://github.com/json4s/json4s/tree/master/scalaz)\r\n\r\nApplicative style parsing with Scalaz\r\n\r\n* [native-lift](https://github.com/json4s/json4s/tree/master/native-lift)\r\n\r\nSupport for Box\r\n\r\nMigration from older versions\r\n=============================\r\n\r\n3.0.0 ->\r\n--------\r\n\r\nJField is no longer a JValue. This means more type safety since it is no longer possible\r\nto create invalid JSON where JFields are added directly into JArrays for instance. Most\r\nnoticeable consequence of this change is that map, transform, find and filter come in\r\ntwo versions:\r\n\r\n```scala\r\ndef map(f: JValue => JValue): JValue\r\ndef mapField(f: JField => JField): JValue\r\ndef transform(f: PartialFunction[JValue, JValue]): JValue\r\ndef transformField(f: PartialFunction[JField, JField]): JValue\r\ndef find(p: JValue => Boolean): Option[JValue]\r\ndef findField(p: JField => Boolean): Option[JField]\r\n//...\r\n```\r\n\r\nUse *Field functions to traverse fields in the JSON, and use the functions without 'Field'\r\nin the name to traverse values in the JSON.\r\n\r\n2.2 ->\r\n------\r\n\r\nPath expressions were changed after 2.2 version. Previous versions returned JField which\r\nunnecessarily complicated the use of the expressions. If you have used path expressions\r\nwith pattern matching like:\r\n\r\n    val JField(\"bar\", JInt(x)) = json \\ \"foo\" \\ \"bar\"\r\n\r\nIt is now required to change that to:\r\n\r\n    val JInt(x) = json \\ \"foo\" \\ \"bar\"\r\n\r\nParsing JSON\r\n============\r\n\r\nAny valid json can be parsed into internal AST format.\r\nFor native support:\r\n\r\n    scala> import org.json4s._\r\n    scala> import org.json4s.native.JsonMethods._\r\n    scala> parse(\"\"\" { \"numbers\" : [1, 2, 3, 4] } \"\"\")\r\n    res0: org.json4s.JsonAST.JValue =\r\n          JObject(List((numbers,JArray(List(JInt(1), JInt(2), JInt(3), JInt(4))))))\r\n    scala> parse(\"\"\"{\"name\":\"Toy\",\"price\":35.35}\"\"\", useBigDecimalForDouble = true)\r\n    res1: org.json4s.package.JValue = \r\n          JObject(List((name,JString(Toy)), (price,JDecimal(35.35))))\r\n\r\nFor jackson support:\r\n\r\n    scala> import org.json4s._\r\n    scala> import org.json4s.jackson.JsonMethods._\r\n    scala> parse(\"\"\" { \"numbers\" : [1, 2, 3, 4] } \"\"\")\r\n    res0: org.json4s.JsonAST.JValue =\r\n          JObject(List((numbers,JArray(List(JInt(1), JInt(2), JInt(3), JInt(4))))))\r\n    scala> parse(\"\"\"{\"name\":\"Toy\",\"price\":35.35}\"\"\", useBigDecimalForDouble = true)\r\n    res1: org.json4s.package.JValue = \r\n          JObject(List((name,JString(Toy)), (price,JDecimal(35.35))))\r\n\r\n\r\n\r\nProducing JSON\r\n==============\r\n\r\nYou can generate json in 2 modes either in `DoubleMode` or in `BigDecimalMode`; the former will map all decimal values\r\ninto a JDouble the latter into a JDecimal.\r\n\r\nFor the double mode dsl use:\r\n\r\n```scala\r\nimport org.json4s.JsonDSL._\r\n// or\r\nimport org.json4s.JsonDSL.WithDouble._\r\n```\r\n\r\nFor the big decimal mode dsl use:\r\n\r\n```scala\r\nimport org.json4s.JsonDSL.WithBigDecimal._\r\n```\r\n\r\n\r\nDSL rules\r\n---------\r\n\r\n* Primitive types map to JSON primitives.\r\n* Any seq produces JSON array.\r\n\r\n      scala> val json = List(1, 2, 3)\r\n\r\n      scala> compact(render(json))\r\n\r\n      res0: String = [1,2,3]\r\n\r\n* Tuple2[String, A] produces field.\r\n\r\n      scala> val json = (\"name\" -> \"joe\")\r\n\r\n      scala> compact(render(json))\r\n\r\n      res1: String = {\"name\":\"joe\"}\r\n\r\n* ~ operator produces object by combining fields.\r\n\r\n      scala> val json = (\"name\" -> \"joe\") ~ (\"age\" -> 35)\r\n\r\n      scala> compact(render(json))\r\n\r\n      res2: String = {\"name\":\"joe\",\"age\":35}\r\n\r\n* Any value can be optional. Field and value is completely removed when it doesn't have a value.\r\n\r\n      scala> val json = (\"name\" -> \"joe\") ~ (\"age\" -> Some(35))\r\n\r\n      scala> compact(render(json))\r\n\r\n      res3: String = {\"name\":\"joe\",\"age\":35}\r\n\r\n      scala> val json = (\"name\" -> \"joe\") ~ (\"age\" -> (None: Option[Int]))\r\n\r\n      scala> compact(render(json))\r\n\r\n      res4: String = {\"name\":\"joe\"}\r\n\r\n* Extending the dsl\r\n  To extend the dsl with your own classes you must have an implicit conversion in scope of signature:\r\n```scala\r\ntype DslConversion = T => JValue\r\n```\r\n\r\nExample\r\n-------\r\n\r\n```scala\r\nobject JsonExample extends App {\r\n  import org.json4s._\r\n  import org.json4s.JsonDSL._\r\n\r\n  case class Winner(id: Long, numbers: List[Int])\r\n  case class Lotto(id: Long, winningNumbers: List[Int], winners: List[Winner], drawDate: Option[java.util.Date])\r\n\r\n  val winners = List(Winner(23, List(2, 45, 34, 23, 3, 5)), Winner(54, List(52, 3, 12, 11, 18, 22)))\r\n  val lotto = Lotto(5, List(2, 45, 34, 23, 7, 5, 3), winners, None)\r\n\r\n  val json =\r\n    (\"lotto\" ->\r\n      (\"lotto-id\" -> lotto.id) ~\r\n      (\"winning-numbers\" -> lotto.winningNumbers) ~\r\n      (\"draw-date\" -> lotto.drawDate.map(_.toString)) ~\r\n      (\"winners\" ->\r\n        lotto.winners.map { w =>\r\n          ((\"winner-id\" -> w.id) ~\r\n           (\"numbers\" -> w.numbers))}))\r\n\r\n  println(compact(render(json)))\r\n}\r\n```\r\n\r\n    scala> JsonExample\r\n    {\"lotto\":{\"lotto-id\":5,\"winning-numbers\":[2,45,34,23,7,5,3],\"winners\":\r\n    [{\"winner-id\":23,\"numbers\":[2,45,34,23,3,5]},{\"winner-id\":54,\"numbers\":[52,3,12,11,18,22]}]}}\r\n\r\nExample produces following pretty printed JSON. Notice that draw-date field is not rendered since its value is None:\r\n\r\n    scala> pretty(render(JsonExample.json))\r\n\r\n    {\r\n      \"lotto\":{\r\n        \"lotto-id\":5,\r\n        \"winning-numbers\":[2,45,34,23,7,5,3],\r\n        \"winners\":[{\r\n          \"winner-id\":23,\r\n          \"numbers\":[2,45,34,23,3,5]\r\n        },{\r\n          \"winner-id\":54,\r\n          \"numbers\":[52,3,12,11,18,22]\r\n        }]\r\n      }\r\n    }\r\n\r\nMerging & Diffing\r\n-----------------\r\n\r\nTwo JSONs can be merged and diffed with each other.\r\nPlease see more examples in [MergeExamples.scala](https://github.com/json4s/json4s/blob/master/tests/src/test/scala/org/json4s/MergeExamples.scala) and [DiffExamples.scala](https://github.com/json4s/json4s/blob/master/tests/src/test/scala/org/json4s/DiffExamples.scala).\r\n\r\n    scala> import org.json4s._\r\n\r\n    scala> import org.json4s.jackson.JsonMethods._\r\n\r\n    scala> val lotto1 = parse(\"\"\"{\r\n             \"lotto\":{\r\n               \"lotto-id\":5,\r\n               \"winning-numbers\":[2,45,34,23,7,5,3]\r\n               \"winners\":[{\r\n                 \"winner-id\":23,\r\n                 \"numbers\":[2,45,34,23,3,5]\r\n               }]\r\n             }\r\n           }\"\"\")\r\n\r\n    scala> val lotto2 = parse(\"\"\"{\r\n             \"lotto\":{\r\n               \"winners\":[{\r\n                 \"winner-id\":54,\r\n                 \"numbers\":[52,3,12,11,18,22]\r\n               }]\r\n             }\r\n           }\"\"\")\r\n\r\n    scala> val mergedLotto = lotto1 merge lotto2\r\n    scala> pretty(render(mergedLotto))\r\n    res0: String =\r\n    {\r\n      \"lotto\":{\r\n        \"lotto-id\":5,\r\n        \"winning-numbers\":[2,45,34,23,7,5,3],\r\n        \"winners\":[{\r\n          \"winner-id\":23,\r\n          \"numbers\":[2,45,34,23,3,5]\r\n        },{\r\n          \"winner-id\":54,\r\n          \"numbers\":[52,3,12,11,18,22]\r\n        }]\r\n      }\r\n    }\r\n\r\n    scala> val Diff(changed, added, deleted) = mergedLotto diff lotto1\r\n    changed: org.json4s.JsonAST.JValue = JNothing\r\n    added: org.json4s.JsonAST.JValue = JNothing\r\n    deleted: org.json4s.JsonAST.JValue = JObject(List((lotto,JObject(List(JField(winners,\r\n    JArray(List(JObject(List((winner-id,JInt(54)), (numbers,JArray(\r\n    List(JInt(52), JInt(3), JInt(12), JInt(11), JInt(18), JInt(22))))))))))))))\r\n\r\n\r\nQuerying JSON\r\n=============\r\n\r\n\"LINQ\" style\r\n------------\r\n\r\nJSON values can be extracted using for-comprehensions.\r\nPlease see more examples in [JsonQueryExamples.scala](https://github.com/json4s/json4s/blob/master/tests/src/test/scala/org/json4s/JsonQueryExamples.scala).\r\n\r\n    scala> import org.json4s._\r\n    scala> import org.json4s.native.JsonMethods._\r\n    scala> val json = parse(\"\"\"\r\n             { \"name\": \"joe\",\r\n               \"children\": [\r\n                 {\r\n                   \"name\": \"Mary\",\r\n                   \"age\": 5\r\n                 },\r\n                 {\r\n                   \"name\": \"Mazy\",\r\n                   \"age\": 3\r\n                 }\r\n               ]\r\n             }\r\n           \"\"\")\r\n\r\n    scala> for { JField(\"age\", JInt(age)) <- json } yield age\r\n    res0: List[BigInt] = List(5, 3)\r\n\r\n    scala> for {\r\n             JObject(child) <- json\r\n             JField(\"name\", JString(name)) <- child\r\n             JField(\"age\", JInt(age)) <- child\r\n             if age > 4\r\n           } yield (name, age)\r\n    res1: List[(String, BigInt)] = List((Mary,5))\r\n\r\nXPath + HOFs\r\n------------\r\n\r\nJson AST can be queried using XPath like functions. Following REPL session shows the usage of\r\n'\\\\', '\\\\\\\\', 'find', 'filter', 'transform', 'remove' and 'values' functions.\r\n\r\n    The example json is:\r\n\r\n    {\r\n      \"person\": {\r\n        \"name\": \"Joe\",\r\n        \"age\": 35,\r\n        \"spouse\": {\r\n          \"person\": {\r\n            \"name\": \"Marilyn\"\r\n            \"age\": 33\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    Translated to DSL syntax:\r\n\r\n    scala> import org.json4s._\r\n\r\n    scala> import org.json4s.native.JsonMethods._\r\n\r\n    or \r\n\r\n    scala> import org.json4s.jackson.JsonMethods._\r\n\r\n    scala> import org.json4s.JsonDSL._\r\n\r\n    scala> val json =\r\n      (\"person\" ->\r\n        (\"name\" -> \"Joe\") ~\r\n        (\"age\" -> 35) ~\r\n        (\"spouse\" ->\r\n          (\"person\" ->\r\n            (\"name\" -> \"Marilyn\") ~\r\n            (\"age\" -> 33)\r\n          )\r\n        )\r\n      )\r\n\r\n    scala> json \\\\ \"spouse\"\r\n    res0: org.json4s.JsonAST.JValue = JObject(List(\r\n          (person,JObject(List((name,JString(Marilyn)), (age,JInt(33)))))))\r\n\r\n    scala> compact(render(res0))\r\n    res1: String = {\"person\":{\"name\":\"Marilyn\",\"age\":33}}\r\n\r\n    scala> compact(render(json \\\\ \"name\"))\r\n    res2: String = {\"name\":\"Joe\",\"name\":\"Marilyn\"}\r\n\r\n    scala> compact(render((json removeField { _ == JField(\"name\", JString(\"Marilyn\")) }) \\\\ \"name\"))\r\n    res3: String = {\"name\":\"Joe\"}\r\n\r\n    scala> compact(render(json \\ \"person\" \\ \"name\"))\r\n    res4: String = \"Joe\"\r\n\r\n    scala> compact(render(json \\ \"person\" \\ \"spouse\" \\ \"person\" \\ \"name\"))\r\n    res5: String = \"Marilyn\"\r\n\r\n    scala> json findField {\r\n             case JField(\"name\", _) => true\r\n             case _ => false\r\n           }\r\n    res6: Option[org.json4s.JsonAST.JValue] = Some((name,JString(Joe)))\r\n\r\n    scala> json filterField {\r\n             case JField(\"name\", _) => true\r\n             case _ => false\r\n           }\r\n    res7: List[org.json4s.JsonAST.JField] = List(JField(name,JString(Joe)), JField(name,JString(Marilyn)))\r\n\r\n    scala> json transformField {\r\n             case JField(\"name\", JString(s)) => (\"NAME\", JString(s.toUpperCase))\r\n           }\r\n    res8: org.json4s.JsonAST.JValue = JObject(List((person,JObject(List(\r\n    (NAME,JString(JOE)), (age,JInt(35)), (spouse,JObject(List(\r\n    (person,JObject(List((NAME,JString(MARILYN)), (age,JInt(33)))))))))))))\r\n\r\n    scala> json.values\r\n    res8: scala.collection.immutable.Map[String,Any] = Map(person -> Map(name -> Joe, age -> 35, spouse -> Map(person -> Map(name -> Marilyn, age -> 33))))\r\n\r\nIndexed path expressions work too and values can be unboxed using type expressions.\r\n\r\n    scala> val json = parse(\"\"\"\r\n             { \"name\": \"joe\",\r\n               \"children\": [\r\n                 {\r\n                   \"name\": \"Mary\",\r\n                   \"age\": 5\r\n                 },\r\n                 {\r\n                   \"name\": \"Mazy\",\r\n                   \"age\": 3\r\n                 }\r\n               ]\r\n             }\r\n           \"\"\")\r\n\r\n    scala> (json \\ \"children\")(0)\r\n    res0: org.json4s.JsonAST.JValue = JObject(List((name,JString(Mary)), (age,JInt(5))))\r\n\r\n    scala> (json \\ \"children\")(1) \\ \"name\"\r\n    res1: org.json4s.JsonAST.JValue = JString(Mazy)\r\n\r\n    scala> json \\\\ classOf[JInt]\r\n    res2: List[org.json4s.JsonAST.JInt#Values] = List(5, 3)\r\n\r\n    scala> json \\ \"children\" \\\\ classOf[JString]\r\n    res3: List[org.json4s.JsonAST.JString#Values] = List(Mary, Mazy)\r\n\r\nExtracting values\r\n=================\r\n\r\nCase classes can be used to extract values from parsed JSON. Non-existing values\r\ncan be extracted into scala.Option and strings can be automatically converted into\r\njava.util.Dates.\r\nPlease see more examples in [ExtractionExampleSpec.scala](https://github.com/json4s/json4s/blob/master/tests/src/test/scala/org/json4s/ExtractionExamplesSpec.scala).\r\n\r\n    scala> import org.json4s._\r\n    scala> import org.json4s.jackson.JsonMethods._\r\n    scala> implicit val formats = DefaultFormats // Brings in default date formats etc.\r\n    scala> case class Child(name: String, age: Int, birthdate: Option[java.util.Date])\r\n    scala> case class Address(street: String, city: String)\r\n    scala> case class Person(name: String, address: Address, children: List[Child])\r\n    scala> val json = parse(\"\"\"\r\n             { \"name\": \"joe\",\r\n               \"address\": {\r\n                 \"street\": \"Bulevard\",\r\n                 \"city\": \"Helsinki\"\r\n               },\r\n               \"children\": [\r\n                 {\r\n                   \"name\": \"Mary\",\r\n                   \"age\": 5\r\n                   \"birthdate\": \"2004-09-04T18:06:22Z\"\r\n                 },\r\n                 {\r\n                   \"name\": \"Mazy\",\r\n                   \"age\": 3\r\n                 }\r\n               ]\r\n             }\r\n           \"\"\")\r\n\r\n    scala> json.extract[Person]\r\n    res0: Person = Person(joe,Address(Bulevard,Helsinki),List(Child(Mary,5,Some(Sat Sep 04 18:06:22 EEST 2004)), Child(Mazy,3,None)))\r\n\r\nBy default the constructor parameter names must match json field names. However, sometimes json\r\nfield names contain characters which are not allowed characters in Scala identifiers. There's two\r\nsolutions for this (see [LottoExample.scala](https://github.com/json4s/json4s/blob/master/tests/src/test/scala/org/json4s/LottoExample.scala) for bigger example).\r\n\r\nUse back ticks.\r\n\r\n    scala> case class Person(`first-name`: String)\r\n\r\nUse transform function to postprocess AST.\r\n\r\n    scala> case class Person(firstname: String)\r\n    scala> json transformField {\r\n             case (\"first-name\", x) => (\"firstname\", x)\r\n           }\r\n\r\nExtraction function tries to find the best matching constructor when case class has auxiliary\r\nconstructors. For instance extracting from JSON {\"price\":350} into the following case class\r\nwill use the auxiliary constructor instead of the primary constructor.\r\n\r\n    scala> case class Bike(make: String, price: Int) {\r\n             def this(price: Int) = this(\"Trek\", price)\r\n           }\r\n    scala> parse(\"\"\" {\"price\":350} \"\"\").extract[Bike]\r\n    res0: Bike = Bike(Trek,350)\r\n\r\nPrimitive values can be extracted from JSON primitives or fields.\r\n\r\n    scala> (json \\ \"name\").extract[String]\r\n    res0: String = \"joe\"\r\n\r\n    scala> ((json \\ \"children\")(0) \\ \"birthdate\").extract[Date]\r\n    res1: java.util.Date = Sat Sep 04 21:06:22 EEST 2004\r\n\r\nDateFormat can be changed by overriding 'DefaultFormats' (or by implmenting trait 'Formats').\r\n\r\n    scala> implicit val formats = new DefaultFormats {\r\n             override def dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\")\r\n           }\r\n\r\nJSON object can be extracted to Map[String, _] too. Each field becomes a key value pair\r\nin result Map.\r\n\r\n    scala> val json = parse(\"\"\"\r\n             {\r\n               \"name\": \"joe\",\r\n               \"addresses\": {\r\n                 \"address1\": {\r\n                   \"street\": \"Bulevard\",\r\n                   \"city\": \"Helsinki\"\r\n                 },\r\n                 \"address2\": {\r\n                   \"street\": \"Soho\",\r\n                   \"city\": \"London\"\r\n                 }\r\n               }\r\n             }\"\"\")\r\n\r\n    scala> case class PersonWithAddresses(name: String, addresses: Map[String, Address])\r\n    scala> json.extract[PersonWithAddresses]\r\n    res0: PersonWithAddresses(\"joe\", Map(\"address1\" -> Address(\"Bulevard\", \"Helsinki\"),\r\n                                         \"address2\" -> Address(\"Soho\", \"London\")))\r\n\r\n\r\nSerialization\r\n=============\r\n\r\nCase classes can be serialized and deserialized.\r\nPlease see other examples in [SerializationExamples.scala](https://github.com/json4s/json4s/blob/master/tests/src/test/scala/org/json4s/SerializationExamples.scala).\r\n\r\n    scala> import org.json4s._\r\n    scala> import org.json4s.native.Serialization\r\n    scala> import org.json4s.native.Serialization.{read, write}\r\n    scala> implicit val formats = Serialization.formats(NoTypeHints)\r\n    scala> val ser = write(Child(\"Mary\", 5, None))\r\n    scala> read[Child](ser)\r\n    res1: Child = Child(Mary,5,None)\r\n\r\nIf you're using jackson instead of the native one: \r\n\r\n    scala> import org.json4s._\r\n    scala> import org.json4s.jackson.Serialization\r\n    scala> import org.json4s.jackson.Serialization.{read, write}\r\n    scala> implicit val formats = Serialization.formats(NoTypeHints)\r\n    scala> val ser = write(Child(\"Mary\", 5, None))\r\n    scala> read[Child](ser)\r\n    res1: Child = Child(Mary,5,None)\r\n\r\nSerialization supports:\r\n\r\n* Arbitrarily deep case class graphs\r\n* All primitive types, including BigInt and Symbol\r\n* List, Seq, Array, Set and Map (note, keys of the Map must be strings: Map[String, _])\r\n* scala.Option\r\n* java.util.Date\r\n* Polymorphic Lists (see below)\r\n* Recursive types\r\n* Serialization of fields of a class (see below)\r\n* Custom serializer functions for types which are not supported (see below)\r\n\r\nSerializing polymorphic Lists\r\n-----------------------------\r\n\r\nType hints are required when serializing polymorphic (or heterogeneous) Lists. Serialized JSON objects\r\nwill get an extra field named 'jsonClass' (the name can be changed by overriding 'typeHintFieldName' from Formats).\r\n\r\n    scala> trait Animal\r\n    scala> case class Dog(name: String) extends Animal\r\n    scala> case class Fish(weight: Double) extends Animal\r\n    scala> case class Animals(animals: List[Animal])\r\n    scala> implicit val formats = Serialization.formats(ShortTypeHints(List(classOf[Dog], classOf[Fish])))\r\n    scala> val ser = write(Animals(Dog(\"pluto\") :: Fish(1.2) :: Nil))\r\n    ser: String = {\"animals\":[{\"jsonClass\":\"Dog\",\"name\":\"pluto\"},{\"jsonClass\":\"Fish\",\"weight\":1.2}]}\r\n\r\n    scala> read[Animals](ser)\r\n    res0: Animals = Animals(List(Dog(pluto), Fish(1.2)))\r\n\r\nShortTypeHints outputs short classname for all instances of configured objects. FullTypeHints outputs full\r\nclassname. Other strategies can be implemented by extending TypeHints trait.\r\n\r\nSerializing fields of a class\r\n-----------------------------\r\n\r\nTo enable serialization of fields, a FieldSerializer can be added for some type:\r\n\r\n    implicit val formats = DefaultFormats + FieldSerializer[WildDog]()\r\n\r\nNow the type WildDog (and all subtypes) gets serialized with all its fields (+ constructor parameters).\r\nFieldSerializer takes two optional parameters which can be used to intercept the field serialization:\r\n\r\n    case class FieldSerializer[A: Manifest](\r\n      serializer:   PartialFunction[(String, Any), Option[(String, Any)]] = Map(),\r\n      deserializer: PartialFunction[JField, JField] = Map()\r\n    )\r\n\r\nThose PartialFunctions are called just before a field is serialized or deserialized. Some useful PFs to\r\nrename and ignore fields are provided:\r\n\r\n    val dogSerializer = FieldSerializer[WildDog](\r\n      renameTo(\"name\", \"animalname\") orElse ignore(\"owner\"),\r\n      renameFrom(\"animalname\", \"name\"))\r\n\r\n    implicit val formats = DefaultFormats + dogSerializer\r\n\r\nSerializing non-supported types\r\n-------------------------------\r\n\r\nIt is possible to plug in custom serializer + deserializer functions for any type.\r\nNow, if we have a non case class Interval (thus, not supported by default), we can still serialize it\r\nby providing following serializer.\r\n\r\n    scala> class Interval(start: Long, end: Long) {\r\n             val startTime = start\r\n             val endTime = end\r\n           }\r\n\r\n    scala> class IntervalSerializer extends CustomSerializer[Interval](format => (\r\n             {\r\n               case JObject(JField(\"start\", JInt(s)) :: JField(\"end\", JInt(e)) :: Nil) =>\r\n                 new Interval(s.longValue, e.longValue)\r\n             },\r\n             {\r\n               case x: Interval =>\r\n                 JObject(JField(\"start\", JInt(BigInt(x.startTime))) ::\r\n                         JField(\"end\",   JInt(BigInt(x.endTime))) :: Nil)\r\n             }\r\n           ))\r\n\r\n    scala> implicit val formats = Serialization.formats(NoTypeHints) + new IntervalSerializer\r\n\r\nCustom serializer is created by providing two partial functions. The first evaluates to a value\r\nif it can unpack the data from JSON. The second creates the desired JSON if the type matches.\r\n\r\nExtensions\r\n----------\r\n\r\nModule json4s-ext contains extensions to extraction and serialization. Following types are supported.\r\n\r\n    // Lift's box\r\n    implicit val formats = org.json4s.DefaultFormats + new org.json4s.native.ext.JsonBoxSerializer\r\n\r\n    // Scala enums\r\n    implicit val formats = org.json4s.DefaultFormats + new org.json4s.ext.EnumSerializer(MyEnum)\r\n    // or\r\n    implicit val formats = org.json4s.DefaultFormats + new org.json4s.ext.EnumNameSerializer(MyEnum)\r\n\r\n    // Joda Time\r\n    implicit val formats = org.json4s.DefaultFormats ++ org.json4s.ext.JodaTimeSerializers.all\r\n\r\nXML support\r\n===========\r\n\r\nJSON structure can be converted to XML node and vice versa.\r\nPlease see more examples in [XmlExamples.scala](https://github.com/json4s/json4s/blob/master/tests/src/test/scala/org/json4s/XmlExamples.scala).\r\n\r\n    scala> import org.json4s.Xml.{toJson, toXml}\r\n    scala> val xml =\r\n             <users>\r\n               <user>\r\n                 <id>1</id>\r\n                 <name>Harry</name>\r\n               </user>\r\n               <user>\r\n                 <id>2</id>\r\n                 <name>David</name>\r\n               </user>\r\n             </users>\r\n\r\n    scala> val json = toJson(xml)\r\n    scala> pretty(render(json))\r\n    res3: {\r\n      \"users\":{\r\n        \"user\":[{\r\n          \"id\":\"1\",\r\n          \"name\":\"Harry\"\r\n        },{\r\n          \"id\":\"2\",\r\n          \"name\":\"David\"\r\n        }]\r\n      }\r\n    }\r\n\r\nNow, the above example has two problems. First, the id is converted to String while we might want it as an Int. This\r\nis easy to fix by mapping JString(s) to JInt(s.toInt). The second problem is more subtle. The conversion function\r\ndecides to use JSON array because there's more than one user-element in XML. Therefore a structurally equivalent\r\nXML document which happens to have just one user-element will generate a JSON document without JSON array. This\r\nis rarely a desired outcome. These both problems can be fixed by following transformation function.\r\n\r\n    scala> json transformField {\r\n             case (\"id\", JString(s)) => (\"id\", JInt(s.toInt))\r\n             case (\"user\", x: JObject) => (\"user\", JArray(x :: Nil))\r\n           }\r\n\r\nOther direction is supported too. Converting JSON to XML:\r\n\r\n     scala> toXml(json)\r\n     res5: scala.xml.NodeSeq = <users><user><id>1</id><name>Harry</name></user><user><id>2</id><name>David</name></user></users>\r\n\r\nLow level pull parser API\r\n=========================\r\n\r\nPull parser API is provided for cases requiring extreme performance. It improves parsing\r\nperformance by two ways. First, no intermediate AST is generated. Second, you can stop\r\nparsing at any time, skipping rest of the stream. Note, this parsing style is recommended\r\nonly as an optimization. Above mentioned functional APIs are easier to use.\r\n\r\nConsider following example which shows how to parse one field value from a big JSON.\r\n\r\n    scala> val json = \"\"\"\r\n      {\r\n        ...\r\n        \"firstName\": \"John\",\r\n        \"lastName\": \"Smith\",\r\n        \"address\": {\r\n          \"streetAddress\": \"21 2nd Street\",\r\n          \"city\": \"New York\",\r\n          \"state\": \"NY\",\r\n          \"postalCode\": 10021\r\n        },\r\n        \"phoneNumbers\": [\r\n          { \"type\": \"home\", \"number\": \"212 555-1234\" },\r\n          { \"type\": \"fax\", \"number\": \"646 555-4567\" }\r\n        ],\r\n        ...\r\n      }\"\"\"\r\n\r\n    scala> val parser = (p: Parser) => {\r\n             def parse: BigInt = p.nextToken match {\r\n               case FieldStart(\"postalCode\") => p.nextToken match {\r\n                 case IntVal(code) => code\r\n                 case _ => p.fail(\"expected int\")\r\n               }\r\n               case End => p.fail(\"no field named 'postalCode'\")\r\n               case _ => parse\r\n             }\r\n\r\n             parse\r\n           }\r\n\r\n    scala> val postalCode = parse(json, parser)\r\n    postalCode: BigInt = 10021\r\n\r\nPull parser is a function `Parser => A`, in this example it is concretely `Parser => BigInt`.\r\nConstructed parser recursively reads tokens until it finds `FieldStart(\"postalCode\")`\r\ntoken. After that the next token must be `IntVal`, otherwise parsing fails. It returns parsed\r\ninteger and stops parsing immediately.\r\n\r\nFAQ\r\n===\r\n\r\nQ1: I have a JSON object and I want to extract it to a case class:\r\n\r\n    scala> case class Person(name: String, age: Int)\r\n    scala> val json = \"\"\"{\"name\":\"joe\",\"age\":15}\"\"\"\r\n\r\nBut extraction fails:\r\n\r\n    scala> parse(json).extract[Person]\r\n    org.json4s.MappingException: Parsed JSON values do not match with class constructor\r\n\r\nA1:\r\n\r\nExtraction does not work for classes defined in REPL. Compile the case class definitions\r\nwith scalac and import those to REPL.\r\n\r\nKudos\r\n=====\r\n\r\n* The original idea for DSL syntax was taken from Lift mailing list ([by Marius](http://markmail.org/message/lniven2hn22vhupu)).\r\n\r\n* The idea for AST and rendering was taken from [Real World Haskell book](http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html).\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"One AST to rule them all"}